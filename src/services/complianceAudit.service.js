/**
 * Compliance Audit Service - Compliance-Grade Audit Logging
 *
 * This service provides a high-level API for creating and querying compliance audit logs.
 * It extends beyond standard audit logging with features required for regulatory compliance:
 *
 * Features:
 * - Immutable tamper-proof audit logs with hash chain verification
 * - Automatic sensitivity level detection based on entity type and fields
 * - Automatic regulatory tag assignment (GDPR, PDPL, ZATCA, etc.)
 * - Geographic location tracking for access monitoring
 * - Changed field detection and tracking
 * - Retention policy management
 * - Integrity verification and export capabilities
 *
 * Use this service for compliance-critical operations that require:
 * - Legal defensibility
 * - Regulatory reporting (GDPR, ZATCA, Labor Law, etc.)
 * - Forensic investigation capabilities
 * - Audit trail reconstruction
 */

const ComplianceAudit = require('../models/complianceAudit.model');
const mongoose = require('mongoose');
const logger = require('../utils/logger');

class ComplianceAuditService {
  // ═══════════════════════════════════════════════════════════════
  // CORE LOGGING METHODS
  // ═══════════════════════════════════════════════════════════════

  /**
   * Log a compliance audit entry
   * @param {Object} params - Audit log parameters
   * @param {String} params.action - Action performed (e.g., 'create', 'update', 'delete')
   * @param {String} params.entityType - Type of entity (e.g., 'client', 'invoice', 'case')
   * @param {String} params.entityId - ID of the entity
   * @param {String} params.userId - ID of the user performing the action
   * @param {Object} params.previousState - State before the action
   * @param {Object} params.newState - State after the action
   * @param {Object} params.req - Express request object for extracting metadata
   * @param {String} params.sensitivityLevel - Optional: Manual sensitivity level
   * @param {Array} params.regulatoryTags - Optional: Manual regulatory tags
   * @param {String} params.firmId - Firm ID for multi-tenancy
   * @returns {Promise<Object|null>} - Created audit log or null on failure
   */
  async log(params) {
    try {
      const {
        action,
        entityType,
        entityId,
        userId,
        previousState,
        newState,
        req,
        sensitivityLevel,
        regulatoryTags,
        firmId
      } = params;

      // Get changed fields by comparing previous and new states
      const changedFields = this.getChangedFields(previousState, newState);

      // Auto-determine sensitivity if not provided
      const sensitivity = sensitivityLevel || this.calculateSensitivity(entityType, changedFields);

      // Auto-tag regulations if not provided
      const tags = regulatoryTags || this.getRegulatoryTags(entityType, changedFields);

      // Get geo location if request IP is available
      const geoLocation = req?.ip ? await this.getGeoLocation(req.ip) : null;

      // Prepare log data
      const logData = {
        // Action details
        action,
        entityType,
        entityId: entityId ? new mongoose.Types.ObjectId(entityId) : null,

        // User context
        userId: userId ? new mongoose.Types.ObjectId(userId) : null,

        // Session and network
        sessionId: req?.session?.id || req?.sessionID || null,
        ipAddress: req?.ip || req?.connection?.remoteAddress || 'unknown',
        userAgent: req?.headers?.['user-agent'] || 'unknown',
        geoLocation,

        // State tracking
        previousState: previousState || null,
        newState: newState || null,
        changedFields,

        // Compliance metadata
        sensitivityLevel: sensitivity,
        regulatoryTags: tags,

        // Retention
        retentionCategory: this.getRetentionCategory(sensitivity),
        expiresAt: this.calculateExpiration(sensitivity),

        // Multi-tenancy
        firmId: firmId ? new mongoose.Types.ObjectId(firmId) : null,

        // Timestamp
        timestamp: new Date()
      };

      // Remove null/undefined fields to keep logs clean
      Object.keys(logData).forEach(key => {
        if (logData[key] === null || logData[key] === undefined) {
          delete logData[key];
        }
      });

      // Create the log entry (checksum and previousLogHash generated by model)
      return await ComplianceAudit.log(logData);
    } catch (error) {
      logger.error('ComplianceAuditService.log failed:', error.message);
      return null;
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // CHANGED FIELDS DETECTION
  // ═══════════════════════════════════════════════════════════════

  /**
   * Get changed fields between two states
   * @param {Object} previousState - State before changes
   * @param {Object} newState - State after changes
   * @returns {Array<String>} - Array of changed field names
   */
  getChangedFields(previousState, newState) {
    if (!previousState || !newState) return [];

    const changes = [];
    const allKeys = new Set([
      ...Object.keys(previousState || {}),
      ...Object.keys(newState || {})
    ]);

    for (const key of allKeys) {
      // Skip internal fields
      if (key.startsWith('_') || key === '__v' || key === 'updatedAt') {
        continue;
      }

      // Compare values (deep comparison via JSON)
      const prevValue = previousState[key];
      const newValue = newState[key];

      if (JSON.stringify(prevValue) !== JSON.stringify(newValue)) {
        changes.push(key);
      }
    }

    return changes;
  }

  // ═══════════════════════════════════════════════════════════════
  // AUTOMATIC SENSITIVITY CALCULATION
  // ═══════════════════════════════════════════════════════════════

  /**
   * Calculate sensitivity level based on entity type and changed fields
   * @param {String} entityType - Type of entity
   * @param {Array<String>} changedFields - Fields that were changed
   * @returns {String} - Sensitivity level: 'low', 'medium', 'high', 'critical'
   */
  calculateSensitivity(entityType, changedFields = []) {
    // Critical entities - always high sensitivity
    const criticalEntities = ['payment', 'invoice', 'salary', 'employee', 'payroll'];
    if (criticalEntities.includes(entityType)) {
      return 'critical';
    }

    // Sensitive fields - trigger high sensitivity
    const sensitiveFields = [
      'salary',
      'ssn',
      'nationalId',
      'bank_account',
      'bankAccount',
      'password',
      'creditCard',
      'accountNumber',
      'routingNumber',
      'taxId',
      'iban'
    ];

    const hasSensitiveField = changedFields.some(field =>
      sensitiveFields.some(sf => field.toLowerCase().includes(sf.toLowerCase()))
    );

    if (hasSensitiveField) {
      return 'high';
    }

    // Medium sensitivity entities
    const mediumEntities = ['user', 'client', 'contact', 'lead', 'case'];
    if (mediumEntities.includes(entityType)) {
      return 'medium';
    }

    // Default to low
    return 'low';
  }

  // ═══════════════════════════════════════════════════════════════
  // AUTOMATIC REGULATORY TAG ASSIGNMENT
  // ═══════════════════════════════════════════════════════════════

  /**
   * Get regulatory tags based on entity type and changed fields
   * @param {String} entityType - Type of entity
   * @param {Array<String>} changedFields - Fields that were changed
   * @returns {Array<String>} - Array of regulatory tags
   */
  getRegulatoryTags(entityType, changedFields = []) {
    const tags = new Set();

    // GDPR & PDPL - Personal data protection (EU & Saudi Arabia)
    const personalDataEntities = ['contact', 'lead', 'client', 'user', 'employee'];
    if (personalDataEntities.includes(entityType)) {
      tags.add('GDPR');
      tags.add('PDPL');
    }

    // ZATCA - Saudi tax/e-invoicing compliance
    const financialEntities = ['invoice', 'payment', 'transaction'];
    if (financialEntities.includes(entityType)) {
      tags.add('ZATCA');
    }

    // Labor Law - Employment and payroll
    const laborEntities = ['employee', 'salary', 'payroll', 'attendance', 'leave'];
    if (laborEntities.includes(entityType)) {
      tags.add('LABOR_LAW');
    }

    // SOC2 - Security and access control changes
    const securityFields = ['password', 'role', 'permissions', 'access', 'token'];
    const hasSecurityField = changedFields.some(field =>
      securityFields.some(sf => field.toLowerCase().includes(sf.toLowerCase()))
    );

    if (hasSecurityField) {
      tags.add('SOC2');
    }

    return Array.from(tags);
  }

  // ═══════════════════════════════════════════════════════════════
  // RETENTION POLICY MANAGEMENT
  // ═══════════════════════════════════════════════════════════════

  /**
   * Get retention category based on sensitivity level
   * @param {String} sensitivityLevel - Sensitivity level
   * @returns {String} - Retention category
   */
  getRetentionCategory(sensitivityLevel) {
    const categories = {
      critical: 'permanent',
      high: '7_years',
      medium: '5_years',
      low: '2_years'
    };
    return categories[sensitivityLevel] || '2_years';
  }

  /**
   * Calculate expiration date based on sensitivity level
   * @param {String} sensitivityLevel - Sensitivity level
   * @returns {Date|null} - Expiration date or null for permanent retention
   */
  calculateExpiration(sensitivityLevel) {
    const retentionYears = {
      critical: null, // Never expires
      high: 7,
      medium: 5,
      low: 2
    };

    const years = retentionYears[sensitivityLevel];

    if (!years) {
      return null; // Permanent retention
    }

    // Calculate expiration date
    const expiresAt = new Date();
    expiresAt.setFullYear(expiresAt.getFullYear() + years);
    return expiresAt;
  }

  // ═══════════════════════════════════════════════════════════════
  // GEO LOCATION
  // ═══════════════════════════════════════════════════════════════

  /**
   * Get geographic location from IP address
   * @param {String} ip - IP address
   * @returns {Promise<Object|null>} - Geo location object or null
   *
   * NOTE: This is a stub implementation. In production, integrate with:
   * - MaxMind GeoIP2
   * - IP2Location
   * - ipapi.co
   * - Or any other IP geolocation service
   */
  async getGeoLocation(ip) {
    try {
      // Skip private/local IPs
      if (!ip || ip === 'unknown' || ip.startsWith('127.') || ip.startsWith('192.168.') || ip.startsWith('10.')) {
        return null;
      }

      // TODO: Integrate with IP geolocation service
      // For now, return null. When ready, uncomment and implement:
      /*
      const response = await fetch(`https://ipapi.co/${ip}/json/`);
      const data = await response.json();

      if (data.error) {
        return null;
      }

      return {
        country: data.country_name,
        city: data.city,
        coordinates: [data.longitude, data.latitude]
      };
      */

      return null;
    } catch (error) {
      logger.error('ComplianceAuditService.getGeoLocation failed:', error.message);
      return null;
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // INTEGRITY VERIFICATION
  // ═══════════════════════════════════════════════════════════════

  /**
   * Verify hash chain integrity for a firm
   * @param {String} firmId - Firm ID
   * @param {Object} options - Verification options
   * @param {Number} options.limit - Maximum number of logs to check
   * @returns {Promise<Object>} - Verification result
   */
  async verifyIntegrity(firmId, options = {}) {
    try {
      return await ComplianceAudit.verifyHashChain(firmId, options);
    } catch (error) {
      logger.error('ComplianceAuditService.verifyIntegrity failed:', error.message);
      throw error;
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // QUERY METHODS
  // ═══════════════════════════════════════════════════════════════

  /**
   * Get audit trail for a specific entity
   * @param {String} entityType - Type of entity
   * @param {String} entityId - ID of the entity
   * @param {String} firmId - Firm ID
   * @param {Object} options - Query options
   * @param {Number} options.limit - Maximum number of results
   * @param {Number} options.skip - Number of results to skip
   * @returns {Promise<Array>} - Audit trail entries
   */
  async getAuditTrail(entityType, entityId, firmId, options = {}) {
    try {
      return await ComplianceAudit.getAuditTrail(entityType, entityId, {
        ...options,
        firmId
      });
    } catch (error) {
      logger.error('ComplianceAuditService.getAuditTrail failed:', error.message);
      return [];
    }
  }

  /**
   * Get logs by regulatory tag
   * @param {String} tag - Regulatory tag (e.g., 'GDPR', 'ZATCA')
   * @param {String} firmId - Firm ID
   * @param {Object} options - Query options
   * @param {Number} options.limit - Maximum number of results
   * @param {Number} options.skip - Number of results to skip
   * @param {Date} options.startDate - Filter start date
   * @param {Date} options.endDate - Filter end date
   * @returns {Promise<Array>} - Compliance audit logs
   */
  async getByRegulatoryTag(tag, firmId, options = {}) {
    try {
      return await ComplianceAudit.getByRegulatoryTag(tag, {
        ...options,
        firmId
      });
    } catch (error) {
      logger.error('ComplianceAuditService.getByRegulatoryTag failed:', error.message);
      return [];
    }
  }

  /**
   * Get high-sensitivity logs
   * @param {String} firmId - Firm ID
   * @param {Object} options - Query options
   * @returns {Promise<Array>} - High-sensitivity audit logs
   */
  async getHighSensitivityLogs(firmId, options = {}) {
    try {
      return await ComplianceAudit.getHighSensitivityLogs({
        ...options,
        firmId
      });
    } catch (error) {
      logger.error('ComplianceAuditService.getHighSensitivityLogs failed:', error.message);
      return [];
    }
  }

  /**
   * Get user activity for compliance reporting
   * @param {String} userId - User ID
   * @param {String} firmId - Firm ID
   * @param {Object} dateRange - { startDate, endDate }
   * @param {Object} options - Query options
   * @returns {Promise<Array>} - User activity logs
   */
  async getUserActivity(userId, firmId, dateRange = {}, options = {}) {
    try {
      return await ComplianceAudit.getUserActivity(userId, dateRange, {
        ...options,
        firmId
      });
    } catch (error) {
      logger.error('ComplianceAuditService.getUserActivity failed:', error.message);
      return [];
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // EXPORT FUNCTIONALITY
  // ═══════════════════════════════════════════════════════════════

  /**
   * Export logs for compliance with optional formatting
   * @param {String} firmId - Firm ID
   * @param {Object} filters - Filter criteria
   * @param {String} filters.userId - Filter by user ID
   * @param {String} filters.action - Filter by action
   * @param {String} filters.entityType - Filter by entity type
   * @param {Date} filters.startDate - Filter start date
   * @param {Date} filters.endDate - Filter end date
   * @param {String} filters.sensitivityLevel - Filter by sensitivity level
   * @param {Array} filters.regulatoryTags - Filter by regulatory tags
   * @param {String} format - Export format: 'json', 'csv', or 'pdf'
   * @returns {Promise<Object>} - { data, format, filename }
   */
  async exportLogs(firmId, filters = {}, format = 'json') {
    try {
      // Add firmId to filters
      const exportFilters = { ...filters, firmId };

      // Get logs from model
      const logs = await ComplianceAudit.exportLogs(exportFilters);

      // Generate filename with timestamp
      const timestamp = new Date().toISOString().split('T')[0];
      const filename = `compliance-audit-${timestamp}`;

      // Format data based on requested format
      switch (format) {
        case 'csv':
          return {
            data: this._convertToCSV(logs),
            format: 'csv',
            filename: `${filename}.csv`
          };

        case 'pdf':
          // TODO: Implement PDF export using pdfme.service or similar
          // For now, return JSON with a note
          logger.warn('PDF export not yet implemented, returning JSON');
          return {
            data: logs,
            format: 'json',
            filename: `${filename}.json`,
            note: 'PDF export not yet implemented'
          };

        case 'json':
        default:
          return {
            data: logs,
            format: 'json',
            filename: `${filename}.json`
          };
      }
    } catch (error) {
      logger.error('ComplianceAuditService.exportLogs failed:', error.message);
      return {
        data: [],
        format,
        error: error.message
      };
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // HELPER METHODS
  // ═══════════════════════════════════════════════════════════════

  /**
   * Convert audit logs to CSV format
   * @private
   * @param {Array} logs - Array of audit logs
   * @returns {String} - CSV formatted string
   */
  _convertToCSV(logs) {
    if (!logs || logs.length === 0) {
      return '';
    }

    // SECURITY: Import sanitization function to prevent CSV injection
    const { sanitizeForCSV } = require('../utils/securityUtils');

    const headers = [
      'Timestamp',
      'Action',
      'Entity Type',
      'Entity ID',
      'User ID',
      'IP Address',
      'Session ID',
      'Sensitivity Level',
      'Regulatory Tags',
      'Changed Fields',
      'Geo Location',
      'Checksum'
    ];

    const csvRows = logs.map(log => [
      sanitizeForCSV(log.timestamp?.toISOString() || ''),
      sanitizeForCSV(log.action || ''),
      sanitizeForCSV(log.entityType || ''),
      sanitizeForCSV(log.entityId?.toString() || ''),
      sanitizeForCSV(log.userId?.toString() || ''),
      sanitizeForCSV(log.ipAddress || ''),
      sanitizeForCSV(log.sessionId || ''),
      sanitizeForCSV(log.sensitivityLevel || ''),
      sanitizeForCSV((log.regulatoryTags || []).join('; ')),
      sanitizeForCSV((log.changedFields || []).join('; ')),
      sanitizeForCSV(log.geoLocation ? `${log.geoLocation.city}, ${log.geoLocation.country}` : ''),
      sanitizeForCSV(log.checksum || '')
    ]);

    const csv = [
      headers.join(','),
      ...csvRows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
    ].join('\n');

    return csv;
  }
}

// Export singleton instance
module.exports = new ComplianceAuditService();
