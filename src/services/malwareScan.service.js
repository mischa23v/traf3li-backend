/**
 * Malware Scanning Service - Multi-Provider Support
 *
 * Provides malware scanning capabilities for file uploads.
 * Supports multiple scanning providers:
 * - ClamAV (self-hosted, unlimited)
 * - VirusTotal API (free tier: 500 scans/day)
 *
 * Features:
 * - Scan files by path or buffer
 * - Automatic fallback between providers
 * - Health check for scan services
 * - Graceful degradation in dev/prod environments
 * - Security event logging
 *
 * Configuration:
 * - MALWARE_SCAN_PROVIDER: 'clamav' | 'virustotal' | 'auto' (default: 'auto')
 * - VIRUSTOTAL_API_KEY: Your VirusTotal API key (free tier available)
 * - CLAMAV_HOST: ClamAV daemon host (default: localhost)
 * - CLAMAV_PORT: ClamAV daemon port (default: 3310)
 * - ENABLE_MALWARE_SCAN: 'false' to disable (default: enabled)
 */

const NodeClam = require('clamscan');
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const auditLogService = require('./auditLog.service');
const logger = require('../utils/logger');

// Rate limiting for VirusTotal (4 requests per minute)
const VT_RATE_LIMIT = {
  requests: 0,
  resetTime: Date.now(),
  maxRequests: 4,
  windowMs: 60000 // 1 minute
};

class MalwareScanService {
  constructor() {
    this.clamav = null;
    this.isInitialized = false;
    this.initializationError = null;
    this.provider = process.env.MALWARE_SCAN_PROVIDER || 'auto';
    this.vtApiKey = process.env.VIRUSTOTAL_API_KEY;
    this.auditLogService = auditLogService;
  }

  /**
   * Check if malware scanning is enabled
   */
  get enabled() {
    return process.env.ENABLE_MALWARE_SCAN !== 'false';
  }

  /**
   * Initialize the malware scanner
   * @returns {Promise<boolean>} - True if initialized successfully
   */
  async initialize() {
    if (this.isInitialized) {
      return true;
    }

    if (!this.enabled) {
      logger.info('Malware scanning is disabled (ENABLE_MALWARE_SCAN=false)');
      return false;
    }

    // Determine which provider to use
    if (this.provider === 'auto') {
      // Try ClamAV first, fall back to VirusTotal
      const clamInitialized = await this._initializeClamAV();
      if (clamInitialized) {
        this.provider = 'clamav';
        return true;
      }

      if (this.vtApiKey) {
        const vtInitialized = await this._initializeVirusTotal();
        if (vtInitialized) {
          this.provider = 'virustotal';
          return true;
        }
      }

      logger.warn('No malware scanning provider available');
      return false;
    }

    if (this.provider === 'clamav') {
      return await this._initializeClamAV();
    }

    if (this.provider === 'virustotal') {
      return await this._initializeVirusTotal();
    }

    return false;
  }

  /**
   * Initialize ClamAV scanner
   * @private
   */
  async _initializeClamAV() {
    try {
      const clamavHost = process.env.CLAMAV_HOST || 'localhost';
      const clamavPort = parseInt(process.env.CLAMAV_PORT || '3310', 10);

      logger.info(`Initializing ClamAV connection to ${clamavHost}:${clamavPort}...`);

      this.clamav = await new NodeClam().init({
        removeInfected: false,
        quarantineInfected: false,
        scanLog: null,
        debugMode: process.env.NODE_ENV === 'development',
        clamdscan: {
          host: clamavHost,
          port: clamavPort,
          timeout: 60000,
          localFallback: false,
          path: '/usr/bin/clamdscan',
          configFile: null,
          multiscan: true,
          reloadDb: false,
          active: true,
          bypassTest: false,
        },
        preferenceOrder: 'clamdscan',
      });

      const version = await this.clamav.getVersion();
      logger.info(`ClamAV initialized successfully. Version: ${version}`);

      this.isInitialized = true;
      this.initializationError = null;
      return true;
    } catch (error) {
      logger.warn('ClamAV not available:', error.message);
      this.initializationError = error.message;
      return false;
    }
  }

  /**
   * Initialize VirusTotal API
   * @private
   */
  async _initializeVirusTotal() {
    if (!this.vtApiKey) {
      logger.warn('VirusTotal API key not configured (VIRUSTOTAL_API_KEY)');
      this.initializationError = 'VirusTotal API key not configured';
      return false;
    }

    try {
      // Test API key with a simple request
      const response = await fetch('https://www.virustotal.com/api/v3/users/current', {
        headers: {
          'x-apikey': this.vtApiKey
        }
      });

      if (response.ok) {
        const data = await response.json();
        logger.info(`VirusTotal initialized. Account: ${data.data?.attributes?.email || 'API Key Valid'}`);
        this.isInitialized = true;
        this.initializationError = null;
        return true;
      } else {
        throw new Error(`API returned ${response.status}`);
      }
    } catch (error) {
      logger.warn('VirusTotal initialization failed:', error.message);
      this.initializationError = error.message;
      return false;
    }
  }

  /**
   * Check if scanner is healthy and responding
   * @returns {Promise<Object>} - Health status object
   */
  async isHealthy() {
    try {
      if (!this.enabled) {
        return {
          healthy: false,
          enabled: false,
          message: 'Malware scanning is disabled'
        };
      }

      if (!this.isInitialized) {
        await this.initialize();
      }

      if (this.provider === 'clamav' && this.clamav) {
        const version = await this.clamav.getVersion();
        return {
          healthy: true,
          enabled: true,
          provider: 'clamav',
          version,
          message: 'ClamAV daemon is healthy'
        };
      }

      if (this.provider === 'virustotal' && this.vtApiKey) {
        return {
          healthy: true,
          enabled: true,
          provider: 'virustotal',
          message: 'VirusTotal API is configured',
          rateLimit: {
            remaining: VT_RATE_LIMIT.maxRequests - VT_RATE_LIMIT.requests,
            resetsIn: Math.max(0, VT_RATE_LIMIT.resetTime + VT_RATE_LIMIT.windowMs - Date.now())
          }
        };
      }

      return {
        healthy: false,
        enabled: true,
        message: this.initializationError || 'No scanner available'
      };
    } catch (error) {
      return {
        healthy: false,
        enabled: this.enabled,
        message: error.message,
        error: error.toString()
      };
    }
  }

  /**
   * Scan a file for malware
   * @param {String} filePath - Absolute path to the file to scan
   * @param {Object} context - Additional context for logging
   * @returns {Promise<Object>} - Scan result { clean: boolean, virus?: string }
   */
  async scanFile(filePath, context = {}) {
    try {
      if (!this.enabled) {
        return { clean: true, skipped: true, reason: 'Scanning disabled' };
      }

      if (!this.isInitialized) {
        const initialized = await this.initialize();
        if (!initialized) {
          return this._handleScanFailure('No scanner available', context);
        }
      }

      // Validate file exists
      try {
        await fs.access(filePath);
      } catch (error) {
        throw new Error(`File not found: ${filePath}`);
      }

      const stats = await fs.stat(filePath);
      const fileSizeMB = (stats.size / 1024 / 1024).toFixed(2);
      logger.info(`Scanning file: ${path.basename(filePath)} (${fileSizeMB} MB) via ${this.provider}`);

      // Route to appropriate provider
      if (this.provider === 'clamav') {
        return await this._scanWithClamAV(filePath, context);
      }

      if (this.provider === 'virustotal') {
        const buffer = await fs.readFile(filePath);
        return await this._scanWithVirusTotal(buffer, path.basename(filePath), context);
      }

      return this._handleScanFailure('No scanner configured', context);
    } catch (error) {
      logger.error('Malware scan error:', error.message);
      return this._handleScanFailure(error.message, context);
    }
  }

  /**
   * Scan a buffer for malware
   * @param {Buffer} buffer - File buffer to scan
   * @param {String} fileName - Original file name
   * @param {Object} context - Additional context for logging
   * @returns {Promise<Object>} - Scan result
   */
  async scanBuffer(buffer, fileName = 'unknown', context = {}) {
    try {
      if (!this.enabled) {
        return { clean: true, skipped: true, reason: 'Scanning disabled' };
      }

      if (!this.isInitialized) {
        const initialized = await this.initialize();
        if (!initialized) {
          return this._handleScanFailure('No scanner available', context);
        }
      }

      const fileSizeMB = (buffer.length / 1024 / 1024).toFixed(2);
      logger.info(`Scanning buffer: ${fileName} (${fileSizeMB} MB) via ${this.provider}`);

      if (this.provider === 'clamav') {
        return await this._scanBufferWithClamAV(buffer, fileName, context);
      }

      if (this.provider === 'virustotal') {
        return await this._scanWithVirusTotal(buffer, fileName, context);
      }

      return this._handleScanFailure('No scanner configured', context);
    } catch (error) {
      logger.error('Malware scan error:', error.message);
      return this._handleScanFailure(error.message, { ...context, fileName });
    }
  }

  /**
   * Scan file with ClamAV
   * @private
   */
  async _scanWithClamAV(filePath, context) {
    const scanResult = await this.clamav.isInfected(filePath);

    if (scanResult.isInfected) {
      const virusName = scanResult.viruses?.[0] || 'Unknown';
      logger.error(`MALWARE DETECTED: ${virusName} in ${path.basename(filePath)}`);

      await this._logSecurityEvent('malware_detected', {
        ...context,
        filePath,
        fileName: path.basename(filePath),
        virus: virusName,
        provider: 'clamav'
      });

      return {
        clean: false,
        virus: virusName,
        viruses: scanResult.viruses,
        provider: 'clamav'
      };
    }

    logger.info(`File clean: ${path.basename(filePath)}`);
    return { clean: true, provider: 'clamav' };
  }

  /**
   * Scan buffer with ClamAV
   * @private
   */
  async _scanBufferWithClamAV(buffer, fileName, context) {
    const scanResult = await this.clamav.scanBuffer(buffer);

    if (scanResult.isInfected) {
      const virusName = scanResult.viruses?.[0] || 'Unknown';
      logger.error(`MALWARE DETECTED: ${virusName} in buffer (${fileName})`);

      await this._logSecurityEvent('malware_detected', {
        ...context,
        fileName,
        fileSize: buffer.length,
        virus: virusName,
        provider: 'clamav'
      });

      return {
        clean: false,
        virus: virusName,
        viruses: scanResult.viruses,
        provider: 'clamav'
      };
    }

    logger.info(`Buffer clean: ${fileName}`);
    return { clean: true, provider: 'clamav' };
  }

  /**
   * Scan with VirusTotal API
   * @private
   */
  async _scanWithVirusTotal(buffer, fileName, context) {
    // Check rate limit
    const now = Date.now();
    if (now > VT_RATE_LIMIT.resetTime + VT_RATE_LIMIT.windowMs) {
      VT_RATE_LIMIT.requests = 0;
      VT_RATE_LIMIT.resetTime = now;
    }

    if (VT_RATE_LIMIT.requests >= VT_RATE_LIMIT.maxRequests) {
      logger.warn('VirusTotal rate limit reached, skipping scan');
      return {
        clean: true,
        skipped: true,
        reason: 'Rate limit exceeded, try again in 1 minute',
        provider: 'virustotal'
      };
    }

    VT_RATE_LIMIT.requests++;

    try {
      // Check file size (VirusTotal limit is 32MB for free tier)
      if (buffer.length > 32 * 1024 * 1024) {
        logger.warn(`File too large for VirusTotal: ${(buffer.length / 1024 / 1024).toFixed(2)} MB`);
        return {
          clean: true,
          skipped: true,
          reason: 'File exceeds VirusTotal size limit (32MB)',
          provider: 'virustotal'
        };
      }

      // Calculate file hash
      const fileHash = crypto.createHash('sha256').update(buffer).digest('hex');

      // First, check if file is already analyzed
      const checkResponse = await fetch(`https://www.virustotal.com/api/v3/files/${fileHash}`, {
        headers: { 'x-apikey': this.vtApiKey }
      });

      if (checkResponse.ok) {
        // File already analyzed, use cached result
        const data = await checkResponse.json();
        const stats = data.data?.attributes?.last_analysis_stats;

        if (stats) {
          const maliciousCount = stats.malicious || 0;
          const suspiciousCount = stats.suspicious || 0;

          if (maliciousCount > 0 || suspiciousCount > 2) {
            logger.error(`MALWARE DETECTED: ${maliciousCount} engines flagged ${fileName}`);

            await this._logSecurityEvent('malware_detected', {
              ...context,
              fileName,
              fileSize: buffer.length,
              virus: `${maliciousCount} engines detected threats`,
              provider: 'virustotal',
              hash: fileHash
            });

            return {
              clean: false,
              virus: `Detected by ${maliciousCount} antivirus engines`,
              stats,
              provider: 'virustotal'
            };
          }

          logger.info(`File clean (cached): ${fileName}`);
          return { clean: true, provider: 'virustotal', cached: true };
        }
      }

      // File not in database, upload for scanning
      const formData = new FormData();
      const blob = new Blob([buffer], { type: 'application/octet-stream' });
      formData.append('file', blob, fileName);

      const uploadResponse = await fetch('https://www.virustotal.com/api/v3/files', {
        method: 'POST',
        headers: { 'x-apikey': this.vtApiKey },
        body: formData
      });

      if (!uploadResponse.ok) {
        throw new Error(`VirusTotal upload failed: ${uploadResponse.status}`);
      }

      const uploadData = await uploadResponse.json();
      const analysisId = uploadData.data?.id;

      if (!analysisId) {
        throw new Error('No analysis ID returned from VirusTotal');
      }

      // Poll for results (max 30 seconds)
      for (let i = 0; i < 6; i++) {
        await new Promise(resolve => setTimeout(resolve, 5000)); // Wait 5 seconds

        const analysisResponse = await fetch(`https://www.virustotal.com/api/v3/analyses/${analysisId}`, {
          headers: { 'x-apikey': this.vtApiKey }
        });

        if (analysisResponse.ok) {
          const analysisData = await analysisResponse.json();
          const status = analysisData.data?.attributes?.status;

          if (status === 'completed') {
            const stats = analysisData.data?.attributes?.stats;
            const maliciousCount = stats?.malicious || 0;
            const suspiciousCount = stats?.suspicious || 0;

            if (maliciousCount > 0 || suspiciousCount > 2) {
              logger.error(`MALWARE DETECTED: ${maliciousCount} engines flagged ${fileName}`);

              await this._logSecurityEvent('malware_detected', {
                ...context,
                fileName,
                fileSize: buffer.length,
                virus: `${maliciousCount} engines detected threats`,
                provider: 'virustotal',
                hash: fileHash
              });

              return {
                clean: false,
                virus: `Detected by ${maliciousCount} antivirus engines`,
                stats,
                provider: 'virustotal'
              };
            }

            logger.info(`File clean: ${fileName}`);
            return { clean: true, provider: 'virustotal' };
          }
        }
      }

      // Analysis taking too long, assume clean for now
      logger.warn(`VirusTotal analysis timeout for ${fileName}, assuming clean`);
      return {
        clean: true,
        pending: true,
        reason: 'Analysis still in progress',
        provider: 'virustotal'
      };

    } catch (error) {
      logger.error('VirusTotal scan error:', error.message);
      throw error;
    }
  }

  /**
   * Handle scan failures
   * @private
   */
  _handleScanFailure(errorMessage, context) {
    const isProd = process.env.NODE_ENV === 'production';

    this._logSecurityEvent('malware_scan_failed', {
      ...context,
      errorMessage,
      environment: process.env.NODE_ENV
    }).catch(err => logger.error('Failed to log scan failure:', err));

    if (isProd) {
      return {
        clean: false,
        error: errorMessage,
        blocked: true,
        reason: 'Unable to verify file safety in production environment'
      };
    } else {
      logger.warn(`Malware scan failed in dev environment, allowing upload: ${errorMessage}`);
      return {
        clean: true,
        warning: errorMessage,
        skipped: true,
        reason: 'Scan unavailable in development'
      };
    }
  }

  /**
   * Log security event to audit log
   * @private
   */
  async _logSecurityEvent(action, details) {
    try {
      await this.auditLogService.log(
        action,
        'file_upload',
        null,
        null,
        {
          userId: details.userId || null,
          ipAddress: details.ipAddress || details.ip || 'unknown',
          userAgent: details.userAgent || 'unknown',
          severity: action === 'malware_detected' ? 'critical' : 'high',
          complianceTags: ['security', 'malware', 'file-upload'],
          details: {
            action,
            fileName: details.fileName,
            filePath: details.filePath,
            fileSize: details.fileSize,
            virus: details.virus,
            errorMessage: details.errorMessage,
            environment: details.environment,
            provider: details.provider,
          },
          status: action === 'malware_detected' ? 'blocked' : 'warning',
        }
      );
    } catch (error) {
      logger.error('Failed to log security event:', error.message);
    }
  }

  /**
   * Get scanner status
   * @returns {Promise<Object>} - Scanner status
   */
  async getStatus() {
    const health = await this.isHealthy();

    return {
      enabled: this.enabled,
      initialized: this.isInitialized,
      healthy: health.healthy,
      provider: this.provider,
      version: health.version,
      error: this.initializationError,
      environment: process.env.NODE_ENV,
      config: {
        provider: this.provider,
        clamav: {
          host: process.env.CLAMAV_HOST || 'localhost',
          port: process.env.CLAMAV_PORT || '3310',
        },
        virustotal: {
          configured: !!this.vtApiKey,
          rateLimit: health.rateLimit
        }
      }
    };
  }
}

// Export singleton instance
module.exports = new MalwareScanService();
