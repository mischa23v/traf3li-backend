/**
 * Malware Scanning Service - ClamAV Integration
 *
 * Provides malware scanning capabilities for file uploads using ClamAV.
 * Supports both local ClamAV daemon and TCP socket connections.
 *
 * Features:
 * - Scan files by path or buffer
 * - Health check for ClamAV daemon
 * - Graceful degradation in dev/prod environments
 * - Security event logging
 */

const NodeClam = require('clamscan');
const fs = require('fs').promises;
const path = require('path');
const auditLogService = require('./auditLog.service');
const logger = require('../utils/logger');

class MalwareScanService {
  constructor() {
    this.clamav = null;
    this.isInitialized = false;
    this.initializationError = null;
    this.enabled = process.env.ENABLE_MALWARE_SCAN === 'true';
    this.auditLogService = auditLogService;
  }

  /**
   * Initialize ClamAV scanner
   * @returns {Promise<boolean>} - True if initialized successfully
   */
  async initialize() {
    if (this.isInitialized) {
      return true;
    }

    if (!this.enabled) {
      logger.info('Malware scanning is disabled (ENABLE_MALWARE_SCAN=false)');
      return false;
    }

    try {
      const clamavHost = process.env.CLAMAV_HOST || 'localhost';
      const clamavPort = parseInt(process.env.CLAMAV_PORT || '3310', 10);

      logger.info(`Initializing ClamAV connection to ${clamavHost}:${clamavPort}...`);

      this.clamav = await new NodeClam().init({
        removeInfected: false, // Don't auto-remove, let app handle it
        quarantineInfected: false, // Don't quarantine
        scanLog: null, // Don't write scan log to disk
        debugMode: process.env.NODE_ENV === 'development',

        // ClamAV daemon settings
        clamdscan: {
          host: clamavHost,
          port: clamavPort,
          timeout: 60000, // 60 seconds
          localFallback: false, // Don't fall back to local binary
          path: '/usr/bin/clamdscan', // Path to clamdscan binary (if needed)
          configFile: null, // Use daemon config
          multiscan: true, // Enable multi-threaded scanning
          reloadDb: false, // Don't reload DB on each scan
          active: true, // Use clamdscan if available
          bypassTest: false, // Always test the connection
        },

        // Preference order: prefer daemon over local binary
        preferenceOrder: 'clamdscan',
      });

      // Test the connection
      const version = await this.clamav.getVersion();
      logger.info(`ClamAV initialized successfully. Version: ${version}`);

      this.isInitialized = true;
      this.initializationError = null;
      return true;
    } catch (error) {
      logger.error('Failed to initialize ClamAV:', error.message);
      this.initializationError = error.message;
      this.isInitialized = false;

      // In production, this is a critical error
      if (process.env.NODE_ENV === 'production') {
        logger.error('CRITICAL: ClamAV not available in production environment');
      } else {
        logger.warn('ClamAV not available in development - scans will be skipped');
      }

      return false;
    }
  }

  /**
   * Check if ClamAV daemon is healthy and responding
   * @returns {Promise<Object>} - Health status object
   */
  async isHealthy() {
    try {
      if (!this.enabled) {
        return {
          healthy: false,
          enabled: false,
          message: 'Malware scanning is disabled'
        };
      }

      if (!this.isInitialized) {
        await this.initialize();
      }

      if (!this.clamav) {
        return {
          healthy: false,
          enabled: true,
          message: this.initializationError || 'ClamAV not initialized'
        };
      }

      // Ping the daemon
      const version = await this.clamav.getVersion();

      return {
        healthy: true,
        enabled: true,
        version,
        message: 'ClamAV daemon is healthy'
      };
    } catch (error) {
      return {
        healthy: false,
        enabled: this.enabled,
        message: error.message,
        error: error.toString()
      };
    }
  }

  /**
   * Scan a file for malware
   * @param {String} filePath - Absolute path to the file to scan
   * @param {Object} context - Additional context for logging (userId, fileName, etc.)
   * @returns {Promise<Object>} - Scan result { clean: boolean, virus?: string, error?: string }
   */
  async scanFile(filePath, context = {}) {
    try {
      // If scanning is disabled, return clean
      if (!this.enabled) {
        return { clean: true, skipped: true, reason: 'Scanning disabled' };
      }

      // Ensure ClamAV is initialized
      if (!this.isInitialized) {
        const initialized = await this.initialize();
        if (!initialized) {
          return this._handleScanFailure('ClamAV not available', context);
        }
      }

      // Validate file exists
      try {
        await fs.access(filePath);
      } catch (error) {
        throw new Error(`File not found: ${filePath}`);
      }

      // Get file stats for logging
      const stats = await fs.stat(filePath);
      const fileSizeMB = (stats.size / 1024 / 1024).toFixed(2);

      logger.info(`Scanning file: ${path.basename(filePath)} (${fileSizeMB} MB)`);

      // Perform the scan
      const scanResult = await this.clamav.isInfected(filePath);

      if (scanResult.isInfected) {
        // Malware detected!
        const virusName = scanResult.viruses && scanResult.viruses.length > 0
          ? scanResult.viruses[0]
          : 'Unknown';

        logger.error(`MALWARE DETECTED: ${virusName} in ${path.basename(filePath)}`);

        // Log security event
        await this._logSecurityEvent('malware_detected', {
          ...context,
          filePath,
          fileName: path.basename(filePath),
          fileSize: stats.size,
          virus: virusName,
          scanResult: scanResult,
        });

        return {
          clean: false,
          virus: virusName,
          viruses: scanResult.viruses,
          scanResult: scanResult
        };
      }

      // File is clean
      logger.info(`File clean: ${path.basename(filePath)}`);

      return {
        clean: true,
        scanResult: scanResult
      };
    } catch (error) {
      logger.error('Malware scan error:', error.message);
      return this._handleScanFailure(error.message, context);
    }
  }

  /**
   * Scan a buffer/stream for malware
   * @param {Buffer} buffer - File buffer to scan
   * @param {String} fileName - Original file name (for logging)
   * @param {Object} context - Additional context for logging
   * @returns {Promise<Object>} - Scan result { clean: boolean, virus?: string, error?: string }
   */
  async scanBuffer(buffer, fileName = 'unknown', context = {}) {
    try {
      // If scanning is disabled, return clean
      if (!this.enabled) {
        return { clean: true, skipped: true, reason: 'Scanning disabled' };
      }

      // Ensure ClamAV is initialized
      if (!this.isInitialized) {
        const initialized = await this.initialize();
        if (!initialized) {
          return this._handleScanFailure('ClamAV not available', context);
        }
      }

      const fileSizeMB = (buffer.length / 1024 / 1024).toFixed(2);
      logger.info(`Scanning buffer: ${fileName} (${fileSizeMB} MB)`);

      // Perform the scan
      const scanResult = await this.clamav.scanBuffer(buffer);

      if (scanResult.isInfected) {
        // Malware detected!
        const virusName = scanResult.viruses && scanResult.viruses.length > 0
          ? scanResult.viruses[0]
          : 'Unknown';

        logger.error(`MALWARE DETECTED: ${virusName} in buffer (${fileName})`);

        // Log security event
        await this._logSecurityEvent('malware_detected', {
          ...context,
          fileName,
          fileSize: buffer.length,
          virus: virusName,
          scanResult: scanResult,
        });

        return {
          clean: false,
          virus: virusName,
          viruses: scanResult.viruses,
          scanResult: scanResult
        };
      }

      // Buffer is clean
      logger.info(`Buffer clean: ${fileName}`);

      return {
        clean: true,
        scanResult: scanResult
      };
    } catch (error) {
      logger.error('Malware scan error:', error.message);
      return this._handleScanFailure(error.message, { ...context, fileName });
    }
  }

  /**
   * Handle scan failures with environment-specific behavior
   * @private
   * @param {String} errorMessage - Error message
   * @param {Object} context - Request context
   * @returns {Object} - Error result with appropriate action
   */
  _handleScanFailure(errorMessage, context) {
    const isProd = process.env.NODE_ENV === 'production';

    // Log the failure
    this._logSecurityEvent('malware_scan_failed', {
      ...context,
      errorMessage,
      environment: process.env.NODE_ENV
    }).catch(err => logger.error('Failed to log scan failure:', err));

    if (isProd) {
      // In production, block the upload if scan fails
      return {
        clean: false,
        error: errorMessage,
        blocked: true,
        reason: 'Unable to verify file safety in production environment'
      };
    } else {
      // In development, allow upload with warning
      logger.warn(`Malware scan failed in dev environment, allowing upload: ${errorMessage}`);
      return {
        clean: true,
        warning: errorMessage,
        skipped: true,
        reason: 'Scan unavailable in development'
      };
    }
  }

  /**
   * Log security event to audit log
   * @private
   * @param {String} action - Security action (malware_detected, malware_scan_failed, etc.)
   * @param {Object} details - Event details
   * @returns {Promise<void>}
   */
  async _logSecurityEvent(action, details) {
    try {
      await this.auditLogService.log(
        action,
        'file_upload',
        null, // No specific entity ID
        null, // No before/after changes
        {
          userId: details.userId || null,
          ipAddress: details.ipAddress || details.ip || 'unknown',
          userAgent: details.userAgent || 'unknown',
          severity: action === 'malware_detected' ? 'critical' : 'high',
          complianceTags: ['security', 'malware', 'file-upload'],
          details: {
            action,
            fileName: details.fileName,
            filePath: details.filePath,
            fileSize: details.fileSize,
            virus: details.virus,
            errorMessage: details.errorMessage,
            environment: details.environment,
          },
          status: action === 'malware_detected' ? 'blocked' : 'warning',
        }
      );
    } catch (error) {
      logger.error('Failed to log security event:', error.message);
    }
  }

  /**
   * Get scanner statistics and status
   * @returns {Promise<Object>} - Scanner status and stats
   */
  async getStatus() {
    const health = await this.isHealthy();

    return {
      enabled: this.enabled,
      initialized: this.isInitialized,
      healthy: health.healthy,
      version: health.version,
      error: this.initializationError,
      environment: process.env.NODE_ENV,
      config: {
        host: process.env.CLAMAV_HOST || 'localhost',
        port: process.env.CLAMAV_PORT || '3310',
      }
    };
  }
}

// Export singleton instance
module.exports = new MalwareScanService();
